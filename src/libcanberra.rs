/* automatically generated by rust-bindgen 0.70.1 */
#![allow(unused, non_camel_case_types)]

pub const CA_MAJOR: u32 = 0;
pub const CA_MINOR: u32 = 30;
pub const CA_PROP_MEDIA_NAME: &[u8; 11] = b"media.name\0";
pub const CA_PROP_MEDIA_TITLE: &[u8; 12] = b"media.title\0";
pub const CA_PROP_MEDIA_ARTIST: &[u8; 13] = b"media.artist\0";
pub const CA_PROP_MEDIA_LANGUAGE: &[u8; 15] = b"media.language\0";
pub const CA_PROP_MEDIA_FILENAME: &[u8; 15] = b"media.filename\0";
pub const CA_PROP_MEDIA_ICON: &[u8; 11] = b"media.icon\0";
pub const CA_PROP_MEDIA_ICON_NAME: &[u8; 16] = b"media.icon_name\0";
pub const CA_PROP_MEDIA_ROLE: &[u8; 11] = b"media.role\0";
pub const CA_PROP_EVENT_ID: &[u8; 9] = b"event.id\0";
pub const CA_PROP_EVENT_DESCRIPTION: &[u8; 18] = b"event.description\0";
pub const CA_PROP_EVENT_MOUSE_X: &[u8; 14] = b"event.mouse.x\0";
pub const CA_PROP_EVENT_MOUSE_Y: &[u8; 14] = b"event.mouse.y\0";
pub const CA_PROP_EVENT_MOUSE_HPOS: &[u8; 17] = b"event.mouse.hpos\0";
pub const CA_PROP_EVENT_MOUSE_VPOS: &[u8; 17] = b"event.mouse.vpos\0";
pub const CA_PROP_EVENT_MOUSE_BUTTON: &[u8; 19] = b"event.mouse.button\0";
pub const CA_PROP_WINDOW_NAME: &[u8; 12] = b"window.name\0";
pub const CA_PROP_WINDOW_ID: &[u8; 10] = b"window.id\0";
pub const CA_PROP_WINDOW_ICON: &[u8; 12] = b"window.icon\0";
pub const CA_PROP_WINDOW_ICON_NAME: &[u8; 17] = b"window.icon_name\0";
pub const CA_PROP_WINDOW_X: &[u8; 9] = b"window.x\0";
pub const CA_PROP_WINDOW_Y: &[u8; 9] = b"window.y\0";
pub const CA_PROP_WINDOW_WIDTH: &[u8; 13] = b"window.width\0";
pub const CA_PROP_WINDOW_HEIGHT: &[u8; 14] = b"window.height\0";
pub const CA_PROP_WINDOW_HPOS: &[u8; 12] = b"window.hpos\0";
pub const CA_PROP_WINDOW_VPOS: &[u8; 12] = b"window.vpos\0";
pub const CA_PROP_WINDOW_DESKTOP: &[u8; 15] = b"window.desktop\0";
pub const CA_PROP_WINDOW_X11_DISPLAY: &[u8; 19] = b"window.x11.display\0";
pub const CA_PROP_WINDOW_X11_SCREEN: &[u8; 18] = b"window.x11.screen\0";
pub const CA_PROP_WINDOW_X11_MONITOR: &[u8; 19] = b"window.x11.monitor\0";
pub const CA_PROP_WINDOW_X11_XID: &[u8; 15] = b"window.x11.xid\0";
pub const CA_PROP_APPLICATION_NAME: &[u8; 17] = b"application.name\0";
pub const CA_PROP_APPLICATION_ID: &[u8; 15] = b"application.id\0";
pub const CA_PROP_APPLICATION_VERSION: &[u8; 20] = b"application.version\0";
pub const CA_PROP_APPLICATION_ICON: &[u8; 17] = b"application.icon\0";
pub const CA_PROP_APPLICATION_ICON_NAME: &[u8; 22] = b"application.icon_name\0";
pub const CA_PROP_APPLICATION_LANGUAGE: &[u8; 21] = b"application.language\0";
pub const CA_PROP_APPLICATION_PROCESS_ID: &[u8; 23] = b"application.process.id\0";
pub const CA_PROP_APPLICATION_PROCESS_BINARY: &[u8; 27] = b"application.process.binary\0";
pub const CA_PROP_APPLICATION_PROCESS_USER: &[u8; 25] = b"application.process.user\0";
pub const CA_PROP_APPLICATION_PROCESS_HOST: &[u8; 25] = b"application.process.host\0";
pub const CA_PROP_CANBERRA_CACHE_CONTROL: &[u8; 23] = b"canberra.cache-control\0";
pub const CA_PROP_CANBERRA_VOLUME: &[u8; 16] = b"canberra.volume\0";
pub const CA_PROP_CANBERRA_XDG_THEME_NAME: &[u8; 24] = b"canberra.xdg-theme.name\0";
pub const CA_PROP_CANBERRA_XDG_THEME_OUTPUT_PROFILE: &[u8; 34] =
    b"canberra.xdg-theme.output-profile\0";
pub const CA_PROP_CANBERRA_ENABLE: &[u8; 16] = b"canberra.enable\0";
pub const CA_PROP_CANBERRA_FORCE_CHANNEL: &[u8; 23] = b"canberra.force_channel\0";
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ca_context {
    _unused: [u8; 0],
}
#[doc = " ca_finish_callback_t:\n @c: The libcanberra context this callback is called for\n @id: The numerical id passed to the ca_context_play_full() when starting the\n event sound playback.\n @error_code: A numerical error code describing the reason this callback is\n called. If CA_SUCCESS is passed in the playback of the event sound was\n successfully completed.\n @userdata: Some arbitrary user data the caller of ca_context_play_full()\n passed in.\n\n Playback completion event callback. The context this callback is\n called in is undefined, it might or might not be called from a\n background thread, and from any stack frame. The code implementing\n this function may not call any libcanberra API call from this\n callback -- this might result in a deadlock. Instead it may only be\n used to asynchronously signal some kind of notification object\n (semaphore, message queue, ...)."]
pub type ca_finish_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        c: *mut ca_context,
        id: u32,
        error_code: ::core::ffi::c_int,
        userdata: *mut ::core::ffi::c_void,
    ),
>;
pub const CA_SUCCESS: _bindgen_ty_1 = 0;
pub const CA_ERROR_NOTSUPPORTED: _bindgen_ty_1 = -1;
pub const CA_ERROR_INVALID: _bindgen_ty_1 = -2;
pub const CA_ERROR_STATE: _bindgen_ty_1 = -3;
pub const CA_ERROR_OOM: _bindgen_ty_1 = -4;
pub const CA_ERROR_NODRIVER: _bindgen_ty_1 = -5;
pub const CA_ERROR_SYSTEM: _bindgen_ty_1 = -6;
pub const CA_ERROR_CORRUPT: _bindgen_ty_1 = -7;
pub const CA_ERROR_TOOBIG: _bindgen_ty_1 = -8;
pub const CA_ERROR_NOTFOUND: _bindgen_ty_1 = -9;
pub const CA_ERROR_DESTROYED: _bindgen_ty_1 = -10;
pub const CA_ERROR_CANCELED: _bindgen_ty_1 = -11;
pub const CA_ERROR_NOTAVAILABLE: _bindgen_ty_1 = -12;
pub const CA_ERROR_ACCESS: _bindgen_ty_1 = -13;
pub const CA_ERROR_IO: _bindgen_ty_1 = -14;
pub const CA_ERROR_INTERNAL: _bindgen_ty_1 = -15;
pub const CA_ERROR_DISABLED: _bindgen_ty_1 = -16;
pub const CA_ERROR_FORKED: _bindgen_ty_1 = -17;
pub const CA_ERROR_DISCONNECTED: _bindgen_ty_1 = -18;
pub const _CA_ERROR_MAX: _bindgen_ty_1 = -19;
#[doc = " Error codes:\n @CA_SUCCESS: Success\n\n Error codes"]
pub type _bindgen_ty_1 = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ca_proplist {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ca_proplist_create(p: *mut *mut ca_proplist) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ca_proplist_destroy(p: *mut ca_proplist) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ca_proplist_sets(
        p: *mut ca_proplist,
        key: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ca_proplist_setf(
        p: *mut ca_proplist,
        key: *const ::core::ffi::c_char,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ca_proplist_set(
        p: *mut ca_proplist,
        key: *const ::core::ffi::c_char,
        data: *const ::core::ffi::c_void,
        nbytes: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ca_context_create(c: *mut *mut ca_context) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ca_context_set_driver(
        c: *mut ca_context,
        driver: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ca_context_change_device(
        c: *mut ca_context,
        device: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ca_context_open(c: *mut ca_context) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ca_context_destroy(c: *mut ca_context) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ca_context_change_props(c: *mut ca_context, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ca_context_change_props_full(
        c: *mut ca_context,
        p: *mut ca_proplist,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ca_context_play_full(
        c: *mut ca_context,
        id: u32,
        p: *mut ca_proplist,
        cb: ca_finish_callback_t,
        userdata: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ca_context_play(c: *mut ca_context, id: u32, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ca_context_cache_full(c: *mut ca_context, p: *mut ca_proplist) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ca_context_cache(c: *mut ca_context, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ca_context_cancel(c: *mut ca_context, id: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ca_context_playing(
        c: *mut ca_context,
        id: u32,
        playing: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ca_strerror(code: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
}
